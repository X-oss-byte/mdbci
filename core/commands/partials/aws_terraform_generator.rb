# frozen_string_literal: true

require 'date'
require 'socket'
require 'erb'
require 'net/ssh'

# The class generates the Terraform configuration file content for MDBCI configuration
class AwsTerraformGenerator
  CONFIGURATION_FILE_NAME = 'infrastructure.tf'
  KEYFILE_NAME = 'maxscale.pem'

  # Initializer
  # @param aws_service [AwsService] service for execute commands in accordance to the AWS EC2
  # @param aws_config [Hash] AWS params (credentials etc.)
  # @param logger [Out] logger
  # @param configuration_path [String] path of the generated configuration.
  def initialize(aws_service, aws_config, logger, configuration_path)
    @aws_service = aws_service
    @aws_config = aws_config
    @ui = logger
    @configuration_path = configuration_path
    @vpc_generated = false
  end

  def configuration_file_name
    CONFIGURATION_FILE_NAME
  end

  # Header of generated configuration file
  def file_header
    <<-HEADER
    # !! Generated content, do not edit !!
    # Generated by MariaDB Continuous Integration Tool (https://github.com/mariadb-corporation/mdbci)
    #### Created #{Time.now} ####
    HEADER
  end

  # Header of configuration content
  def config_header
    ''
  end

  # Footer of configuration content
  def config_footer
    ''
  end

  # Generate and return provider configuration content for configuration file
  # @return [String] provider configuration content for configuration file
  def generate_provider_config
    @ui.info('Generating AWS configuration')
    generate_keypair
    provider_config
  end

  # Generate the key pair for the AWS.
  def handle_invalid_configuration_case
    @aws_service.delete_key_pair(@keypair_name)
  end

  # Print node info specific for current nodes provider
  def print_node_specific_info(node_params)
    @ui.info("AWS definition for host:#{node_params[:host]}, ami:#{node_params[:amiurl]}, "\
             "user:#{node_params[:user]}, instance:#{node_params[:instance]}")
  end

  # Generate a node definition for the configuration file.
  # @param node_params [Hash] list of the node parameters
  # @param path [String] path of the configuration file
  # @return [String] node definition for the configuration file.
  def generate_node_defenition(node_params, path)
    tags = { hostname: Socket.gethostname, username: Etc.getlogin,
             full_config_path: File.expand_path(path), machinename: node_params[:name] }
    get_vms_definition(tags, node_params)
  end

  private

  def provider_config
    <<-PROVIDER
    provider "aws" {
      profile    = "default"
      region     = "#{@aws_config['region']}"
      access_key = "#{@aws_config['access_key_id']}"
      secret_key = "#{@aws_config['secret_access_key']}"
    }
    locals {
      cidr_vpc = "10.1.0.0/16" # CIDR block for the VPC
      cidr_subnet = "10.1.0.0/24" # CIDR block for the subnet
      availability_zone = "eu-west-1a" # availability zone to create subnet
    }
    #{keypair_resource}
    #{security_group_resource(false)}
    PROVIDER
  end

  def generate_keypair
    key = OpenSSL::PKey::RSA.new(2048)
    type = key.ssh_type
    data = [key.to_blob].pack('m0')
    @public_key_value = "#{type} #{data}"
    @path_to_keyfile = File.join(@configuration_path, KEYFILE_NAME)
    File.open(@path_to_keyfile, 'w') { |file| file.write(key.to_pem) }
    File.chmod(400, @path_to_keyfile)

    hostname = Socket.gethostname
    key_pair_name = File.basename(@configuration_path)
    @key_name = "#{hostname}_#{key_pair_name}_#{Time.now.to_i}"
  end

  def keypair_resource
    <<-KEYPAIR_RESOURCE
    resource "aws_key_pair" "ec2key" {
      key_name = "#{@key_name}"
      public_key = "#{@public_key_value}"
    }
    KEYPAIR_RESOURCE
  end

  def connection_partial(user, name)
    <<-PARTIAL
    connection {
      type        = "ssh"
      private_key = file("#{@path_to_keyfile}")
      timeout     = "2m"
      agent       = false
      user        = "#{user}"
      host        = aws_instance.#{name}.public_ip
    }
    PARTIAL
  end

  def security_group_resource(vpc)
    group_name = "#{Socket.gethostname}_#{Time.now.strftime('%s')}"
    template = ERB.new <<-SECURITY_GROUP
    resource "aws_security_group" "security_group<%= vpc ? '_vpc' : '' %>" {
      name = "<%= group_name %>"
      description = "MDBCI <%= group_name %> auto generated"
      ingress {
        from_port   = 22
        to_port     = 22
        protocol    = "tcp"
        cidr_blocks = ["0.0.0.0/0"]
      }
      <% if vpc %>
        vpc_id = aws_vpc.vpc.id
        egress {
          from_port   = 0
          to_port     = 0
          protocol    = "-1"
          cidr_blocks = ["0.0.0.0/0"]
        }
      <% end %>
    }
    SECURITY_GROUP
    template.result(binding)
  end

  def vpc_resources
    <<-VPC_RESOURCES
    resource "aws_vpc" "vpc" {
      cidr_block = local.cidr_vpc
      enable_dns_support   = true
      enable_dns_hostnames = true
    }
    resource "aws_internet_gateway" "igw" {
      vpc_id = aws_vpc.vpc.id
    }
    resource "aws_subnet" "subnet_public" {
      vpc_id = aws_vpc.vpc.id
      cidr_block = local.cidr_subnet
      map_public_ip_on_launch = "true"
      availability_zone = local.availability_zone
    }
    resource "aws_route_table" "rtb_public" {
      vpc_id = aws_vpc.vpc.id
      route {
          cidr_block = "0.0.0.0/0"
          gateway_id = aws_internet_gateway.igw.id
      }
    }
    resource "aws_route_table_association" "rta_subnet_public" {
      subnet_id      = aws_subnet.subnet_public.id
      route_table_id = aws_route_table.rtb_public.id
    }
    #{security_group_resource(true)}
    VPC_RESOURCES
  end

  # Generate the key pair for the AWS.
  # @param path [String] path of the configuration file
  # @return [Array[String, String]] path to .pem-file and key pair name.
  def generate_key_pair(path)
    full_path = File.expand_path(path)
    key_pair = @aws_service.generate_key_pair(full_path)
    path_to_keyfile = File.join(full_path, KEYFILE_NAME)
    File.write(path_to_keyfile, key_pair.key_material)
    path_to_keypair_file = File.join(full_path, Configuration::AWS_KEYPAIR_NAME)
    File.write(path_to_keypair_file, key_pair.key_name)
    [path_to_keyfile, key_pair.key_name]
  end

  # Generate Terraform configuration of AWS instance
  # @param tags [Hash] tags of AWS instance
  # @param node_params [Hash] list of the node parameters
  # @return [String] configuration content of AWS instance
  # rubocop:disable Metrics/MethodLength
  def get_vms_definition(tags, node_params)
    node_params = node_params.merge(tags: tags)
    connection_block = connection_partial(node_params[:user], node_params[:name])
    vpc_resources_blocks = vpc_resources
    template = ERB.new <<-AWS
    <% if vpc && !@vpc_generated %>
      <%= vpc_resources_blocks %>
    <% end %>
    resource "aws_instance" "<%= name %>" {
      ami             = "<%= ami %>"
      instance_type   = "<%= default_instance_type %>"
      key_name        = aws_key_pair.ec2key.key_name
      <% if vpc %>
        vpc_security_group_ids = [aws_security_group.security_group_vpc.id]
        subnet_id  = aws_subnet.subnet_public.id
        depends_on = [aws_route_table_association.rta_subnet_public, aws_route_table.rtb_public]
      <% else %>
        security_groups = ["default", aws_security_group.security_group.name]
      <% end %>
      tags = {
        <% tags.each do |tag_key, tag_value| %>
          <%= tag_key %> = "<%= tag_value %>"
        <% end %>
      }
      root_block_device {
        volume_size = "500"
      }
      user_data = <<-EOT
      #!/bin/bash
      sed -i -e 's/^Defaults.*requiretty/# Defaults requiretty/g' /etc/sudoers
      EOT
      provisioner "local-exec" {
        command = "echo ${aws_instance.<%= name %>.public_ip} > public_ip_<%= name %>"
      }
      provisioner "local-exec" {
        command = "echo ${aws_instance.<%= name %>.private_ip} > private_ip_<%= name %>"
      }
      provisioner "local-exec" {
        command = "echo <%= user %> > user_<%= name %>"
      }
      provisioner "local-exec" {
        when    = "destroy"
        command = "rm public_ip_<%= name %> private_ip_<%= name %> user_<%= name %>"
      }
      <% if template_path %>
        provisioner "file" {
          source      = "<%=template_path %>"
          destination = "/home/<%= user %>/cnf_templates"
          <%= connection_block %>
        }
        provisioner "remote-exec" {
          inline = [
            "sudo mkdir /home/vagrant",
            "sudo mv /home/<%= user %>/cnf_templates /home/vagrant/cnf_templates"
          ]
          <%= connection_block %>
        }
      <% end %>
    }
    AWS
    result = template.result(OpenStruct.new(node_params).instance_eval { binding })
    @vpc_generated = true if node_params[:vpc]
    result
  end
  # rubocop:enable Metrics/MethodLength
end
